---
title: "Functional analysis of genes and metabolites"
author: "Vincent ROCHER & Juliette COOKE"
format: 
  revealjs:
    fontsize: 24px
    width: 1400
editor: source
execute:
  echo: true
---

# Feature Enrichment Analysis

## Features Functional Analysis

### Gene Functional Analysis program

* Taught by Vincent
* Gene IDs and conversion nightmares
* 2 methods for Gene Functional Analysis:
  1. Over Representation Analysis (ORA)
  2. Gene Set Enrichment Analysis (GSEA)
* Some gene similarity with pathway

## Features Functional Analysis

### Metabolite Functional Analysis

* Taught by Juliette


## Disclaimer

In functional analysis of biological pathway, the biologist is __always__ the expert :

* The pathway database is determinent.
* You decide the relationship and biological significance of the data you want to present.

The Statistician is just here to give you the right tools to discover the __relevant information__ and to __display your data__.

__Differential expression__ analysis and __functional analysis__ are only used to refine your data in order to find relevant information.

# Gene Enrichment Analysis

## Introduction


```{r,echo=F,message=FALSE,warning=F}

require(tidyverse)
require(clusterProfiler)
library(ReactomePA)
require(org.Hs.eg.db)
require(gt)
require(AnnotationHub)
require(BiocHubsShiny)
require(biomaRt)
require(enrichplot)
library(FELLA)
library(KEGGREST)
theme_set(theme_bw(base_size=12)) 
theme_update(panel.background = element_rect(fill = "transparent", colour = NA), 
             plot.background = element_rect(fill = "transparent", colour = NA)) 


# Import list of differentially expressed genes
# de_genes <- read_tsv("../TP/liste_genes.tsv")
DE_result <- read_tsv("../TP/Gene_DE_DIVA.tsv")


de_genes <- DE_result %>% dplyr::filter(p.adj < 0.05,logFC>0.5)


```


### **Definition**:

Gene enrichment analysis identifies __biological pathways__ or __functions__ that are __overrepresented__ in a set of genes of interest.

### Why ?

The interpretation of the list of differentially expressed genes can be challenging due to two scenarios:

1.  The list is so long that it becomes cumbersome and time-consuming to analyze and interpret each gene individually.

2.  Some genes may have low p-values but not low enough to meet the given threshold for significance.

### In such situations, enrichment analysis can be employed to enhance the understanding of our dataset.



## Introduction

Pathway enrichment methods were originally developed for gene enrichment.

They are also widely used with metabolites and metabolomics data, meaning we can apply gene enrichment methods to metabolites (with caution!)

:::{.notes}

Juliette

:::

## Differences vs genes

Metabolomics data has a lower metabolome coverage than genes have of genome coverage, and there is less metabolite data in general.

For metabolites, there is no Gene Ontology equivalent, but ChEBI ontology & pathway sets are close. This means that gaining functional information is more difficult and less standardised.

Metabolite identifier mapping is a major issue: metabolites have multiple names, IDs, isomers and are called different things depending on the database.

There is always a bias depending on input data used for enrichment analyses, more so for metabolomics (some metabolites cannot be detected and will never be used to enrich pathways).

Exo-metabolomics vs endo-metabolomics: metabolites from exo-metabolomics (blood) are further away from internal pathways than endo (cells, tissue).

Finally, it also depends on how pathways have been defined and obtaining a general consensus of metabolic pathways is difficult.


:::{.notes}

Juliette

:::



## Approaches

::: {style="font-size: 22px;"}

To derive biological meaning from the results of differential expression analysis, there are several approaches available. 

### For genes


1.  **Over Representation Analysis (ORA)**: This method determines whether the differentially expressed genes are enriched in specific pathways or ontological groups. It assesses whether the observed number of genes in a particular pathway or gene ontology term is higher than what would be expected by chance.

2.  **Gene Set Enrichment Analysis (GSEA)**: GSEA evaluates whether a pre-defined set of genes (gene set) shows statistically significant differences between two or more biological conditions. Instead of focusing on individual genes, GSEA considers the collective behavior of genes within a gene set to identify enriched biological pathways or functional categories.

### For Metabolites

1. **ORA**: Over-representation analysis (Fisher's exact test)

2. **MSEA**: Metabolite set enrichment analysis, often referred to as GSEA even for metabolites = a Functional Class Scoring (FCS) method

3. **Topology-based methods**: uses networks of pathways in addition to other methods

:::

:::{.notes}

Juliette read For Metabolites

:::

# Before Functionnal analysis

## From (Gene) Symbols to (Gene) IDs

::: {style="font-size: 18px;"}
Working with gene IDs, such as `Ensembl IDs`, instead of gene symbols is important for reproducibility in gene enrichment analysis due to the following reasons:

1.  **Gene Symbol Ambiguity:** Gene symbols can be ambiguous, as multiple genes can have the same symbol. This can lead to confusion and errors when performing analyses, especially when using external databases or tools.

2.  **Uniqueness:** Gene IDs are unique identifiers assigned to specific genes. They provide a standardized and consistent way of referring to genes across different datasets and analyses, ensuring accuracy and reproducibility.

3.  **Consistent Annotation:** Gene IDs are linked to comprehensive and up-to-date gene annotation databases, such as Ensembl. These databases provide detailed information about gene features, genomic locations, functional annotations, and other relevant metadata.

4.  **Cross-Species Comparisons:** Gene IDs enable seamless comparisons of gene enrichment results across different species.

5.  **Data Integration:** Gene IDs facilitate data integration across multiple experiments or studies. They enable the merging of different datasets, such as gene expression data or functional annotations, based on a common identifier.

6.  **Long-term Accessibility:** Gene IDs are stable and persist over time.

Using Gene IDs: enhances reproducibility in gene enrichment analysis by providing unique and standardized gene identifiers, enabling consistent annotation, supporting cross-species comparisons, facilitating data integration, and ensuring long-term accessibility of results.
:::

## Ensembl BioMart

BioMart provides a flexible and intuitive interface to explore and retrieve genomic data from Ensembl. It allows you to filter and select specific data attributes, enabling you to extract the information that is most relevant to your research or analysis.

1.  **Accessing BioMart**: Go to the Ensembl website (<https://www.ensembl.org>) and click on the "BioMart" option in the menu to access the BioMart interface.

2.  **Choosing a Dataset**: In the BioMart interface, you will see several tabs. Start by selecting the "CHOOSE DATABASE" tab. Here, you can choose the dataset you want to retrieve data from, such as the Ensembl genes, variation, or sequence databases.

3.  **Selecting Filters**: Once you've chosen the dataset, click on the "CHOOSE FILTERS" tab. Here, you can specify criteria to filter the data you are interested in. For example, you can filter by gene ID, chromosome location, gene biotype, or other attributes.

4.  **Selecting Attributes**: After setting your filters, switch to the "CHOOSE ATTRIBUTES" tab. Here, you can select the specific attributes or data fields you want to retrieve for the filtered data. These attributes can include gene names, chromosomal coordinates, functional annotations, or any other available information.

5.  **Retrieving Results**: Once you have chosen the desired attributes, switch to the "RESULTS" tab. Click on the "Results" button to retrieve the data based on your chosen filters and attributes. The results will be displayed in a table format.

## BioMart

Ensembl Biomart have an R api called `bioMart`:

::: columns
::: {.column width="50%"}
```{r}
require(biomaRt)
listMarts()
```
:::

::: {.column width="50%"}
```{r}
mart <- biomaRt::useMart(biomart="ENSEMBL_MART_ENSEMBL")
listEnsembl(mart=mart)
```
:::
:::

::: fragment
Check datasets availables

```{r,echo=T,eval=F}
ensembl <- useEnsembl(biomart = "genes")
datasets <- listDatasets(ensembl)
datasets %>% as_tibble() %>% rmarkdown::paged_table()
```

::: {style="font-size: 12px;"}
```{r,echo=F}
ensembl <- useEnsembl(biomart = "genes")
datasets <- listDatasets(ensembl)
datasets %>% as_tibble() %>% rmarkdown::paged_table()
```
:::
:::

## BioMart

### Now we can ask for the same thing but with `R` :

```{r}
ensembl <- useDataset(dataset = "hsapiens_gene_ensembl", mart = ensembl)
```

### If the dataset is known in advance:

```{r,eval=F}

ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
```

## BioMart

### Query in `biomaRt`

The `getBM()` function is the primary query function in biomaRt.

It has four main arguments:

-   `attributes`: is a vector of attributes that one wants to retrieve (= the output of the query).
-   `filters`: is a vector of filters that one wil use as input to the query.
-   `values`: a vector of values for the filters. In case multple filters are in use, the values argument requires a list of values where each position in the list corresponds to the position of the filters in the filters argument (see examples below).
-   `mart`: is an object of class Mart, which is created by the useEnsembl() function.

## BioMart

### Retrieve attributes and filters to query `ensembl`:

::: columns
::: {.column width="50%"}
```{r}
filters = listFilters(ensembl)
filters  %>% as_tibble() %>% rmarkdown::paged_table()
```
:::

::: {.column width="50%"}
```{r}
attributes = listAttributes(ensembl)
attributes %>% as_tibble() %>% rmarkdown::paged_table()
```
:::
:::

## BioMart

### Query with `getBM()`

```{r}
getBM(attributes = c("ensembl_gene_id","entrezgene_id","hgnc_symbol"),
      filters = "ensembl_gene_id",
      values = de_genes$rowname, 
      mart = ensembl)
```

## Using archived versions of Ensembl

```{r}
listEnsemblArchives()
```

```{r}
ensembl.grch37 <- useEnsembl(biomart = 'genes', 
                       dataset = 'hsapiens_gene_ensembl',
                       host = listEnsemblArchives()[1,]$url)
ensembl.grch37
```

## AnnotationHub

### Get proper annotation for `AnnotationHub` using `BiocHubsShiny`:

The `BiocHubsShiny` package allows users to visually explore the `AnnotationHub` and `ExperimentHub` resources via shiny. It provides a tabular display of the available resources with the ability to filter and search through the column fields.[^1]

[^1]: From `BiocHubsShiny` vignette : https://bioconductor.org/packages/release/bioc/vignettes/BiocHubsShiny/inst/doc/BiocHubsShiny.html

```{r,eval=FALSE,echo=T}
BiocHubsShiny::BiocHubsShiny()
```


::: {.callout-warning}
## Caution

`BiocHubsShiny::BiocHubsShiny()` need `bioconductor>=3.17` and `R>=4.3`.

:::

## AnnotationHub

Paste the code from `BiocHubsShiny` and get the `EnsemblDB` object

```{r,eval =F,echo=T}
## Make sure BiocManager is installed
if (!require('BiocManager', quietly = TRUE))
    install.packages('BiocManager')

## Make sure AnnotationHub is installed
if (!require("AnnotationHub", quietly = TRUE))
    BiocManager::install("AnnotationHub")

## Use this code to download the resource
library("AnnotationHub")
hub <- AnnotationHub()

## Select rows in the table
ens.db <- hub[['AH109336']]
ens.db
```

```{r,echo=F,message=F,warning=F}
hub <- AnnotationHub()

## Select rows in the table
ens.db <- hub[['AH109336']]
ens.db
```

## AnnotationHub

### Object description

```{r,echo=T}
columns(ens.db)
```

## AnnotationHub

### Get full gene annotation (gtf like)

::: columns
::: {.column width="40%"}
```{r}
#| warning: false
#| message: false

genes(ens.db)
```
:::

::: {.column width="60%"}
```{r}
#| warning: false
#| message: false

transcripts(ens.db)
```
:::
:::

## AnnotationHub

### Gene ID conversion from `Ensembl` To `Symbol` and `ENTREZ`

```{r,echo=T}
select(ens.db, keys=de_genes$rowname,columns=c("SYMBOL", "GENEID","ENTREZID","GENENAME","GENEBIOTYPE"),keytype = "GENEID")
```

> Note: If you don't have a gene list and want everything, provide `keys=keys(ens.db, keytype="GENEID")` to the `select()` function. 

## AnnotationHub

### Work as well for `NCBI`:

```{r,echo=T}
hub <- AnnotationHub()
org.db <- hub[['AH111575']]
org.db
```

## Retrieve other annotations using `AnnotationHub` or `biomaRt`

### Go Annotations


```{r,warning=FALSE,message=FALSE}
select(org.db, keys = "GO:0030155", column="ENSEMBL",keytype="GOALL")
```

## Retrieve other annotations using `AnnotationHub` or `biomaRt`

### Go Annotations


```{r}
go_list <- getBM(attributes=c("ensembl_gene_id"),
                 filters = "go",
                 values = c("GO:0030155"),
                 mart=ensembl, 
                 uniqueRows = FALSE)
go_list

```

## Retrieve other annotations using `AnnotationHub` or `biomaRt`

### Ortholog

```{r}
mus_musculus_attributes <- listAttributes(ensembl)$name %>% str_subset("mmusculus_homolog")
getBM(attributes = c("ensembl_gene_id",mus_musculus_attributes),
      filters = "ensembl_gene_id",
      values = de_genes$rowname, 
      mart = ensembl)
```


## Databases for Metabolites

### Databases and IDs

-   KEGG, PubChem, ChEBI, MeSH, HMDB are databases which all have their own metabolite IDs, some with links to each other

-   Converting IDs: MetaboAnalyst can convert from names/IDs to many different IDs, KEGG API in R

:::{.notes}

Juliette

:::


# Functionnal analysis

## Approaches

::: {style="font-size: 18px;"}

To derive biological meaning from the results of differential expression analysis, there are several approaches available. Two commonly used methods are:

1.  **Over Representation Analysis (ORA)**: This method determines whether the differentially expressed genes are enriched in specific pathways or ontological groups. It assesses whether the observed number of genes in a particular pathway or gene ontology term is higher than what would be expected by chance.

2.  **Gene Set Enrichment Analysis (GSEA)**: GSEA evaluates whether a pre-defined set of genes (gene set) shows statistically significant differences between two or more biological conditions. Instead of focusing on individual genes, GSEA considers the collective behavior of genes within a gene set to identify enriched biological pathways or functional categories.

:::

## Common sources of feature sets

1. **Gene Ontology (GO)**
2. **KEGG (Kyoto Encyclopedia of Genes and Genomes)**:
3. **WikiPathways**
4. **Disease Ontology**
5. **Reactome**
6. **Molecular Signatures Database (MSigDB)**
7. **Medical Subject Headings (MeSH)**

These pathway collections databases serve as valuable resources for researchers to explore and analyze biological pathways, functional annotations, and disease associations. They facilitate the interpretation of gene expression data, identify key pathways related to specific biological processes or diseases, and contribute to a deeper understanding of biological systems.

## Metabolites pathway sets

Pathway sets are collections of metabolites grouped together based on a metabolic function, sometimes focused around an important metabolite. Some examples are `Glycolysis / Gluconeogenesis`, `Arginine and proline metabolism`, `Fatty acid biosynthesis`.

Pathway sets for metabolomics can be found in different databases:

-   KEGG

-   Reactome

-   Metabolic networks: BiGG / MetabolicAtlas

Pathway definitions are relatively arbitrary and depend on the database. Filtering them may be necessary as many include non metabolic pathways such as cell differenciation processes, immune related pathways, or generic terms such as `Metabolic pathways`.

More pathway sets can be found on BioCyc for example, but it requires an account, and extracting relevant data is complicated.

:::{.notes}

Juliette

:::

## **Gene Ontology (GO)**

::: {style="font-size: 18px;"}

### Website: <http://geneontology.org/>

### Description: 
GO is a widely used database that categorizes genes into three main ontologies: molecular function, biological process, and cellular component. It provides a standardized vocabulary to describe gene functions and interactions, allowing researchers to annotate and analyze gene sets in a structured manner.


1. **Molecular Function**
   - Describes the elemental activities of a gene product at the molecular level.
2. **Biological Process**
   - Represents sets of molecular events or biological pathways achieved by one or more gene products.
   - Biological process terms describe the larger, coordinated series of events that involve multiple molecular functions.
3. **Cellular Component**
   - Refers to the subcellular structures, locations, and macromolecular complexes in which gene products are active.
   - Cellular component terms describe the physical compartments or structures where gene products function.


:::{.callout-tip}
* [Ten Quick Tips for Using the Gene Ontology](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003343)
:::

:::

## **KEGG (Kyoto Encyclopedia of Genes and Genomes)**

KEGG is a Japanese database of genes, pathways, diseases, drugs and more. It contains metabolic pathways as well as many other pathways related to diseases, the immune system, genetic processes, and many more.

Everything in KEGG has its own KEGG ID, and often also has an external ID (such as ChEBI for metabolites).

When studying metabolomics data, we should filter the pathways to only use metabolic pathways (done in the Exercises part of this course).

Using the KEGG API, we can access the database directly inside R.

Information on the KEGG API can be found here: <https://www.kegg.jp/kegg/rest/keggapi.html>

In R, we will be using the [KEGGREST](https://www.bioconductor.org/packages/release/bioc/html/KEGGREST.html) library.

:::{.notes}

Juliette

:::

## `keggList()`

KEGG generic pathways can be listed using keggList and the term "pathway".

```{r, kegg-generic, cache=TRUE}
head(keggList("pathway"))
```

We can also search for pathways of a given species using the 3-letter species codes from KEGG. This is a subset of pathways of the generic pathway, so the pathway IDs are the same with "hsa" instead of "map".

```{r, kegg-human, cache=TRUE}
head(keggList("pathway", "hsa"))
```

:::{.notes}

Juliette

:::

## `keggLink()`

We can link multiple databases using `keggLink()`, for example to get all compounds in each pathway. Because compounds aren't species-specific in KEGG, they are mapped to the generic pathways.

```{r, kegg-link1, cache=TRUE}
head(keggLink("compound", "pathway"))
```

However, genes are species-specific so we can extract all human genes and their pathways directly.

```{r, kegg-link2, cache=TRUE}
head(keggLink("hsa", "pathway"))
```

:::{.notes}

Juliette

:::

## `keggConv()`

To convert all compound KEGG IDs to ChEBI, we can do the following:

```{r, kegg-conv, cache=TRUE}
head(keggConv("compound", "chebi"))
```

We can get a list of all pathways for a given organism, and a list of all compounds per pathway. We can then match them together to get all metabolites organised into pathways for our organism (done in the Exercises part of this course).

:::{.notes}

Juliette

:::

## **WikiPathways**

### Website: <https://www.wikipathways.org/>

### Description

WikiPathways is a community-curated database that focuses on biological pathways. It provides a platform for researchers to collaboratively create, annotate, and update pathway information. WikiPathways covers a wide range of species and offers pathway diagrams, annotations, and links to external resources.

## **Disease Ontology**

### Website: <https://disease-ontology.org/>

### Description
The Disease Ontology (DO) is a structured and standardized ontology that describes human diseases and their relationships. It provides a hierarchical framework to classify and annotate diseases, enabling researchers to study disease-associated genes, pathways, and biological processes.

## **Reactome**

### Website: <https://reactome.org/tools/reactome-fiviz>

### Description
Reactome is a curated database of biological pathways and reactions. It covers a wide range of species and provides detailed pathway information, including molecular events, regulatory processes, and disease associations. Reactome also offers advanced visualization tools and data analysis features.

## **Molecular Signatures Database (MSigDB)**

::: {style="font-size: 18px;"}

### Website: <https://www.gsea-msigdb.org/gsea/msigdb>

### Description
MSigDB is a collection of gene sets that represent various biological concepts and pathways. 
It includes curated gene sets from different sources: 

* H: hallmark gene sets
* C1: positional gene sets
* C2: curated gene sets
* C3: motif gene sets
* C4: computational gene sets
* C5: GO gene sets
* C6: oncogenic signatures
* C7: immunologic signatures

:::

## **Medical Subject Headings (MeSH)**

### Website: <https://disease-ontology.org/>

### Description
MeSH is a controlled vocabulary database developed by the National Library of Medicine (NLM). It provides standardized terminology for biomedical research and categorizes articles in PubMed. MeSH includes hierarchical relationships between terms and enables the identification of relevant articles based on specific topics or concepts.

:::{.callout-note}
* Data source from gendoo, gene2pubmed and RBBH are all supported. User can select interesting category to test. All 16 categories of MeSH are supported. The analysis supports about 200 species.
* MeSH terms were associated with Entrez Gene ID by three methods, gendoo, gene2pubmed and RBBH (Reciprocal Blast Best Hit).
:::

## Over Representation analysis

Over Representation Analysis (ORA) is a widely used approach to determine whether known biological functions or processes are over-represented (= enriched) in an experimentally-derived gene list, e.g. a list of differentially expressed genes (DEGs).

![From bioinformatics-core-shared-training.github.io/Bulk_RNAseq_Course_Apr22](index_files/imgs/genesetoverlap.svg){fig-align="center"}

## Over Representation analysis

![From bioinformatics-core-shared-training.github.io/Bulk_RNAseq_Course_Apr22](index_files/imgs/contingency.png){fig-align="center" width="400" height="300"}

## Fisher Exact Test

-   The Fisher Exact Test is a statistical method used to determine whether there is a significant association between two categorical variables, such as the presence or absence of a particular gene and a particular phenotype or disease.
-   In the context of gene enrichment analysis, the Fisher Exact Test is used to determine whether there is a significant association between a set of genes and a particular biological pathway or process.

Hypothesis: 

* $H_0$: The categories are independent.
* $H_1$: The categories are dependent.

> In Gene Enrichment, we want to see as genes as possible in the pathway that are DE, so we want a one sided test with greater hypothesis.




## Fisher Exact Test

The p-value can be calculated by hypergeometric distribution[^1]: 

$$
p = 1 - \displaystyle\sum_{i = 0}^{k-1}\frac{{M \choose i}{{N-M} \choose {n-i}}} {{N \choose n}}
$$

* $N$ is the total number of genes in the background distribution
* $M$ is the number of genes within that distribution that are annotated (either directly or indirectly) to the gene set of interest
* $n$ is the size of the list of genes of interest
* $k$ is the number of genes within that list which are annotated to the gene set. 

![From Wieder et al. (https://doi.org/10.1371/journal.pcbi.1009105)](images/ora.PNG){fig-align="center" width="250" height="250"}


[^1]: In case of alternative hypothesis as `greater`.

## Fisher Exact Test

### With an (false) example

![From https://www.pathwaycommons.org/guide/primers/statistics/fishers_exact_test/](index_files/imgs/table_1.png){fig-align="center" width="400" height="300"}

## Fisher Exact Test

### With an (false) example

![From https://www.pathwaycommons.org/guide/primers/statistics/fishers_exact_test/](index_files/imgs/figure_1.png){fig-align="center"}



## Fisher Exact Test

### With an (false) example

![From https://www.pathwaycommons.org/guide/primers/statistics/fishers_exact_test/](index_files/imgs/table_2.png){fig-align="center" width="400" height="300"}

## Fisher Exact Test

### Using the Hypergeometric distribution

$$
\begin{equation*}
  \begin{split}
    \frac{(\text{15 Choose 1})\cdot(\text{15 Choose 14})}{(\text{30 Choose 15})}& = \frac{15\cdot15}{155 117 520}\\
    & = 1.45\cdot10^{-6}
  \end{split}
\end{equation*}
$$

## Fisher Exact Test

### With an (false) example

![From https://www.pathwaycommons.org/guide/primers/statistics/fishers_exact_test/](index_files/imgs/figure_3.png){fig-align="center"}

:::{.notes}
Comment calculer la p-value et qu'est-ce que la p-value veut dire ? 
Quelle est a la probabilité que j'observe 12 genes DE+pathway OU PLUS par hasard ?
:::

## Fisher Exact Test

### Solution

$$
\begin{equation*}
  \begin{split}
    p& = \sum\limits_{\text{DE & IN}\geq12}p_i\\
     & = 1.33\cdot10^{-3}+7.11\cdot10^{-5}+1.45\cdot10^{-6}+6.45\cdot10^{-9}\\
     & = 0.001407159\\
     & \simeq 0.0014
  \end{split}
\end{equation*}
$$

## Fisher Exact Test

### With a real dataset 



```{r echo=FALSE, warning=FALSE,message=FALSE}

# go_enrichment <- enrichGO(de_genes$rowname, OrgDb = org.Hs.eg.db, keyType = "ENSEMBL", ont = "BP",universe = DE_result$rowname)
# saveRDS(go_enrichment,"data/go_enrichment.rds")
go_enrichment <- readRDS("data/go_enrichment.rds")
go_enrichment <- setReadable(go_enrichment, OrgDb = org.Hs.eg.db, keyType="ENSEMBL")
my_go <- "GO:0030155"
my_go <- go_enrichment %>% as_tibble() %>% arrange(desc(p.adjust)) %>% dplyr::filter(ID == my_go)

k = 32
M = 203 
N = 10096
n = 448


d <- data.frame(gene.in.interest=c(32,416),gene.not.interest=c(171,9477))
row.names(d) <- c("In_category", "not_in_category")

mytable <- d
mytable <- rbind(mytable,colSums(d))
mytable <- cbind(mytable,rowSums(mytable))
colnames(mytable) <- c("Of_interest_yes", "Of_interest_no","Total")
rownames(mytable) <- c("in_pathway_yes","in_pathway_no","Total")

desired_colnames <- colnames(mytable) |> 
  str_remove('Of_interest_') |> 
  str_to_title()
names(desired_colnames) <- colnames(mytable)


options(scipen=999)

```

For a gene set `r my_go$Description` (`r my_go$ID`), I have :

* `r N` ($N$) number of genes in the analysis (background distribution).
* `r M` ($M$) genes within that distribution that are in the pathway of interest.
* `r n` ($n$) genes of interest (DE).
* `r k` ($k$) genes that are DE AND in the pathway of interest.

And we can draw this contingency table:

```{r echo=FALSE, warning=FALSE,message=FALSE}
options(scipen=0)
mytable %>% tibble::rownames_to_column("Pathway") %>% mutate(Pathway = glue::glue("**Pathway of interest**: {str_extract(Pathway,'yes|no|Total')}")) %>%  gt(rowname_col = "Pathway") %>% cols_label(.list = desired_colnames) |> 
  tab_spanner(
    label = md('**Genes of interest**'),
    columns = 1:2
  ) %>%  fmt_markdown(columns = everything()) %>% 
  tab_header(
    title = glue::glue("Contingency table: DE genes against {my_go$Description} ({my_go$ID})")
  )
```




## Tests with `R`

### Using Hypergeometric distribution


```{r}
all_probas <- dhyper(0:203, M, N-M, n,log=F)
```


```{r,echo=F}
p1 <- enframe(all_probas) %>% ggplot(aes(x=name,y=value)) + geom_line() + labs(y="probability",x="k",title = "Probability of observing our table giving k") + geom_vline(xintercept = 32,linetype='dashed',col="red")
print(p1)
```


## Tests with `R`

### Using Hypergeometric distribution

::: columns
::: {.column width="50%"}
#### Summing all probability having $k=32$ or more : 
```{r}
dhyper(k:M, M, N-M, n,log=F) %>% sum()
```

:::

::: {.column width="50%"}

#### Using the distribution function directly

```{r}
phyper(k-1, M, N-M, n,lower.tail =F)
```

Or even if we want to replicate the formula :

```{r}
1-phyper(k-1, M, N-M, n)
```
:::
:::


### Using Fisher Test directly

```{r}
fisher.test(d, alternative = "greater")
```



## Over-representation analysis (ORA)

ORA for metabolite enrichment is the same method as for genes: it uses Fisher's exact test to test for significant overlap in sets.

-   3 inputs:

    -   a collection of pathways: one pathway is an ID associated with many metabolites. Metabolites can be in multiple pathways.

    -   a list of metabolites of interest (i.e. filtered on p-values or fold changes), with IDs that match the pathway set IDs.

    -   a background set:

        -   targeted metabolomics: all assayed metabolites

        -   untargeted metabolomics: all features that can be annotated


:::{.notes}

Juliette

:::

## ORA: extra information

::: callout-warning
Due to the smaller input datasets in metabolomics, the background set is very important! Use a specific background set corresponding to realistically observable metabolites, not all known metabolites.
:::

Multiple-testing corrections and p-value filtering are necessary to produce list of metabolites of interest. Because input datasets are usually smaller, selecting the correct significant metabolites is very important.

Multiple-testing in ORA is also necessary, however due to the stringent nature of these tests, it's acceptable to use a higher threshold in metabolomics (e.g. 0.1 instead of 0.05), when using a specific background set.

:::{.notes}

Juliette

:::

## Gene Set Enrichment Analysis (GSEA)

* GSEA is a statistical method for analyzing gene expression data that aims to identify sets of genes or pathways that are significantly differentially expressed between two or more biological conditions.
* GSEA does not rely on predefined gene sets, but rather uses all genes in the dataset and ranks them based on their differential expression between the conditions. The method then tests whether genes in a given set are more likely to be located at the top or bottom of the ranked list.
* GSEA can provide insights into the biological processes or pathways that are involved in a specific disease or phenotype, and can help identify potential therapeutic targets.

They may consist in expression levels, p-values, correlations, fold-changes (FC), t-statistics, signal-to-noise ratios, etc.

## Gene Set Enrichment Analysis (GSEA)

![From bioinformatics-core-shared-training.github.io/Bulk_RNAseq_Course_Apr22](index_files/imgs/gsea1.png){fig-align="center"}

## Gene Set Enrichment Analysis (GSEA)

![From bioinformatics-core-shared-training.github.io/Bulk_RNAseq_Course_Apr22](index_files/imgs/gsea2.png){fig-align="center"}

## Gene Set Enrichment Analysis (GSEA)

![From bioinformatics-core-shared-training.github.io/Bulk_RNAseq_Course_Apr22](index_files/imgs/gsea3.png){fig-align="center"}

## Gene Set Enrichment Analysis (GSEA)

![From bioinformatics-core-shared-training.github.io/Bulk_RNAseq_Course_Apr22](index_files/imgs/gsea4.gif){fig-align="center"}

## Gene Set Enrichment Analysis (GSEA)

![From bioinformatics-core-shared-training.github.io/Bulk_RNAseq_Course_Apr22](index_files/imgs/gsea5.gif){fig-align="center"}

## Gene Set Enrichment Analysis

### With a real dataset

```{r echo=FALSE, warning=FALSE,message=FALSE}

geneList <- DE_result %>% dplyr::select(rowname,logFC) %>% arrange(desc(logFC)) %>% deframe() 

# ego <- gseGO(geneList     = geneList,
#              OrgDb        = org.Hs.eg.db,
#              ont          = "BP",
#              keyType = "ENSEMBL",
#              minGSSize    = 100,
#              maxGSSize    = 500,
#              pvalueCutoff = 0.05,
#              verbose      = FALSE)
# saveRDS(ego,"data/ego.rds")
ego <- readRDS("data/ego.rds")

my_go = "GO:0001944"
my_desc <- AnnotationDbi::Term(GO.db::GOTERM)[[my_go]]



enrichplot::gseaplot2(ego, geneSetID = my_go, title = my_desc)
```

## Gene Set Enrichment Analysis

### Against random walks

```{r echo=FALSE, warning=FALSE,message=FALSE,fig.cap="Real ES score computation against random walks by permutation (100)"}
source("usefull_func.R")
datatab.shuff <- 1:100 %>% parallel::mclapply(function(x){
  gsInfo(ego,my_go,shuffle=T)
},mc.cores=10) %>% bind_rows(.id="Shuffle")
datatab <- gsInfo(ego,my_go)



point_score <- datatab.shuff %>% group_by(Shuffle) %>% arrange(desc(abs(runningScore))) %>%
  dplyr::slice(1) 


p2 <- datatab.shuff %>% ggplot()   +
  # geom_segment(data=df2, aes(x=x, xend=x, y=0.05, yend=0),
  #              color="black") + 
  geom_line(aes(x = x,y=runningScore,col=Shuffle),linetype="dashed") +
  geom_line(data=datatab, aes(x = x,y=runningScore)) +
  geom_point(data=point_score,aes(x=x,y=runningScore)) + 
  ggtitle(my_desc) + ylab("Ranked List Metric") + xlab("Position in the Ranked List of Genes") + theme(legend.position="none")





print(p2)
```

## Gene Set Enrichment Analysis

### Against random walks

```{r echo=FALSE, warning=FALSE,message=FALSE,fig.cap="Distribution of NULL distribution using permutation"}

selected.gs <-  ego@geneSets[my_go]

observed_info <- lapply(selected.gs, function(gs)
  gseaScores(geneSet=gs,
             geneList=ego@geneList,
             exponent=1)
)
observedScore <- sapply(observed_info, function(x) x$ES)

# permScores <- parallel::mclapply(1:10000, function(i) {
#   perm.gseaEScore(ego@geneList, selected.gs, 1)
# },mc.cores=10)
# saveRDS(permScores,"data/permScores.rds")
permScores <- readRDS("data/permScores.rds")

permScores <- do.call("cbind", permScores)

rownames(permScores) <- names(selected.gs)

pos.m <- apply(permScores, 1, function(x) mean(x[x >= 0]))
neg.m <- apply(permScores, 1, function(x) abs(mean(x[x < 0])))


# normalized_ES <- function(ES, pos.m, neg.m) {
#   s <- sign(ES)
#   m <- numeric(length(ES))
#   m[s==1] <- pos.m[s==1]
#   m[s==-1] <- neg.m[s==-1]
#   ES/m
# }
# 
# NES <- normalized_ES(observedScore, pos.m, neg.m)
# 
# permScores <- apply(permScores, 2, normalized_ES, pos.m=pos.m, neg.m=neg.m)


p5 <- enframe(permScores[1,]) %>% 
  ggplot(aes(y=value)) + geom_histogram(bins=50) + geom_hline(yintercept = observedScore,col="red",linetype="dashed")

print(p5)
```


## Metabolite set enrichment analysis (MSEA/GSEA)

GSEA, also known as *MSEA* in metabolomics, is the same method as for genes. It requires values associated with each metabolite, uses the unfiltered metabolite dataset. It ranks all metabolite values and tests if closely ranked metabolites enrich the same pathway. Its main advantage is that it can detect subtle and coordinated changes.

GSEA provides a p-value of enrichment for each pathway for significance, and an Enrichment Score of each pathway which indicates up or down regulation of that pathway.

It doesn't require a threshold on input metabolite values as it uses the entire list of metabolites of interest. It therefore doesn't need a background set (background set = all input metabolites). However, this means that when using a partially annotated list of metabolites of interest, the background set is not necessarily representative of what could be measured since non annotated metabolites should still be a part of this set. This is important to take into account for the interpretation of the results as GSEA can only enrich using the input metabolites.

:::{.notes}

Juliette

:::

## GSEA: extra information

In addition to p-values for each pathway, it provides a list of leading genes/metabolites which help enrich each pathway:

> "The leading-edge subset in a gene set are those genes that appear in the ranked list at or before the point at which the running sum reaches its maximum deviation from zero. The leading-edge subset can be interpreted as the core that accounts for the gene set's enrichment signal."

GSEA results do still need a filter on p-value to determine significantly enriched pathways, usually 0.05 or 0.1.

::: callout-warning
Depending on input values/scores, interpretation of pathway regulations can be different! For example the fold change values are one condition / a different condition so be sure to interpret the pathway up/down regulation in that direction.
:::

:::{.notes}

Juliette

:::

## General metabolomics data enrichment warnings

-   Any enrichment method is sensitive to metabolite mis-identification.

-   Use organism-specific pathway set if available.

-   If possible, run multiple times with different pathway databases and enrichment methods and form a consensus.

:::{.notes}

Juliette

:::

## Over Representation Test tools

### Online tools

* PANTHER (<http://geneontology.org/> or <http://www.pantherdb.org/>)
* gprofiler (<https://biit.cs.ut.ee/gprofiler/gost>)
* DAVID (<https://david.ncifcrf.gov/>)
* WEB-based GEne SeT AnaLysis Toolkit (WebGestalt) <https://www.webgestalt.org/>

### Programmatic (R) tools 

* `ClusterProfiler`
* `hypeR`
* `gprofiler2`
* `rbioapi`: R api to query Enrichr, miEAA, PANTHER, Reactome, and STRING.

## Gene Set Enrichment Analysis

### Online tools

* WEB-based GEne SeT AnaLysis Toolkit (WebGestalt) <https://www.webgestalt.org/>
* gsea-msigdb <https://www.gsea-msigdb.org/gsea/index.jsp> (Download required)

### Programmatic tools

* `ClusterProfiler`
* `hypeR`
* `gprofiler2`
* `fgsea` (used internally by ClusterProfiler)



## Tools for Metabolites

-   R: `clusterprofiler`, `FELLA`

-   In addition to R, Python can also be used for enrichment analyses: Python packages include `gseapy` with `gsea()` or `prerank()` functions

-   MetaboAnalyst and IMPaLA: for online analyses

-   Metexplore for visualisation using metabolic networks

:::{.notes}

Juliette

:::

## Some examples with `clusterProfiler`


### We need for that a dataset


```{r}

DE_result <- read_tsv("../TP/Gene_DE_DIVA.tsv")

DE_result

de_genes <- DE_result %>% dplyr::filter(p.adj < 0.05,logFC>0.5)

de_genes %>% dim

geneList <- DE_result %>% dplyr::select(rowname,logFC) %>% arrange(desc(logFC)) %>% deframe() 

```


## Some examples with `clusterProfiler`

### And a `orgDB` object

```{r}
#| message: false
#| warning: false

require(clusterProfiler)
require(org.Hs.eg.db)
org.db <- org.Hs.eg.db

## We can also use our own DB
hub <- AnnotationHub()
org.db <- hub[['AH111575']]
org.db


```

## Some examples with `clusterProfiler`

### Gene classification based on GO distribution at a specific level

```{r}
#| message: false
#| warning: false

ggo <- groupGO(gene     = de_genes$rowname,
               OrgDb        = org.db,
               ont          = "BP",
               keyType = "ENSEMBL",
               level    = 3,
               readable = TRUE)
ggo

ggo %>% as_tibble()
```




## Some examples with `clusterProfiler`

### GO over-representation analysis

The clusterProfiler package implements `enrichGO()` for gene ontology over-representation test.


```{r}
#| message: false
#| warning: false

ego <- enrichGO(gene          = de_genes$rowname,
                universe      = DE_result$rowname,
                OrgDb         = org.db,
                keyType = "ENSEMBL",
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                readable      = TRUE)

ego %>% as_tibble()
```

## Some examples with `clusterProfiler`

### And  `gseGO()` for Gene Set Enrichment Analysis

```{r}
#| message: false
#| warning: false

ego <- gseGO(geneList     = geneList,
             OrgDb        = org.Hs.eg.db,
             ont          = "BP",
             keyType = "ENSEMBL",
             minGSSize    = 100,
             maxGSSize    = 500,
             pvalueCutoff = 0.05,
             verbose      = FALSE)


ego %>% as_tibble()

```


## Some examples with `clusterProfiler`

### Of course Gene IDs may be hard to understand

```{r}
#| message: false
#| warning: false

setReadable(ego, OrgDb = org.db, keyType="ENSEMBL") %>% as_tibble() %>% pull(core_enrichment)


```

## Some examples with `clusterProfiler`

### Enrichment test for KEGG

### Need conversion first

```{r}
#| message: false
#| warning: false
res1 <- select(org.db, keys=de_genes$rowname,columns=c("ENSEMBL","ENTREZID"),keytype = "ENSEMBL")
res2 <- bitr(de_genes$rowname, fromType="ENSEMBL", toType=c("ENTREZID"), OrgDb=org.db)
```

### And then use `enrichKEGG()`

```{r}
#| message: false
#| warning: false


kk <- enrichKEGG(gene         = res2$ENTREZID,
                 organism     = 'hsa',
                 pvalueCutoff = 0.05)

kk %>% as_tibble()
```

## Some examples with `clusterProfiler`

### Or with `enrichMKEGG()` for Modules

```{r}
mkk <- enrichMKEGG(gene = res2$ENTREZID,
                   organism = 'hsa',
                   pvalueCutoff = 1,
                   qvalueCutoff = 1)

mkk %>% as_tibble()
```


## Some examples with `clusterProfiler`

### GSEA for KEGG

### Need conversion first

```{r}
#| message: false
#| warning: false

res2 <- bitr(DE_result$rowname, fromType="ENSEMBL", toType=c("ENTREZID"), OrgDb=org.db)
geneListENTREZ <- DE_result %>% left_join(res2,by=c("rowname"="ENSEMBL")) %>%
  dplyr::select(ENTREZID,logFC) %>%
  arrange(desc(logFC)) %>% 
  drop_na() %>% 
  deframe()
```

### And then use `gseKEGG()`

```{r}
#| message: false
#| warning: false
kk2 <- gseKEGG(geneList     = geneListENTREZ,
               organism     = 'hsa',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)

kk2 %>% as_tibble()
```


## Some examples with `clusterProfiler`

### WikiPathways

```{r}
#| eval: false


get_wp_organisms()

enrichWP(res2$ENTREZID, organism = "Homo sapiens") %>% as_tibble()

gseWP(geneListENTREZ, organism = "Homo sapiens")%>% as_tibble()
```


### Reactome

```{r}
#| eval: false
library(ReactomePA)

enrichPathway(gene=res2$ENTREZID, readable=TRUE) %>% as_tibble()

gsePathway(geneListENTREZ, verbose = FALSE) %>% as_tibble()

```


### DOSE

```{r}
#| eval: false


library(DOSE)


enrichDO(gene=res2$ENTREZID, readable=TRUE) %>% as_tibble()

gseDO(geneListENTREZ, verbose = FALSE) %>% as_tibble()

```

## Some examples with `clusterProfiler`

### Universal enrichment analysis

```{r}
TERM2GENE <- select(org.db, keys = keys(org.db,"GOALL"), column="ENSEMBL",keytype="GOALL") %>% dplyr::select(GOALL,ENSEMBL)
enricher(de_genes$rowname, TERM2GENE = TERM2GENE,universe = DE_result$rowname) %>% as_tibble()
```




## Some examples with `rbioapi`

```{r}
require(rbioapi)
genes <- de_genes$gene_name
```


### Querying Enricher


```{r}
rba_enrichr_libs()
```


## Some examples with `rbioapi`

```{r}
#| eval: false
results_all <- rba_enrichr(gene_list = genes)
```
```r
--Step 1/3:
Retrieving List of available libraries and statistics from Enrichr human.
--Step 2/3:
Uploading 248 gene symbols to Enrichr human.
--Step 3/3:
Performing enrichment analysis on gene-list 62468329 using multiple Enrichr human libraries.
Note: You have selected '211' Enrichr human libraries. Note that for each library, a separate call should be sent to Enrichr server. Thus, this could take a while depending on the number of selected libraries and your network connection.
```

```{r}
#| echo: false

results_all <- readRDS("data/result_all.rds")
```

```{r}
results_all[["GO_Biological_Process_2021"]] %>% as_tibble()
```



## Some examples with `rbioapi`

### Using STRING

STRING let you perform two types of enrichments.

#### We need to map proteins first

```{r}
proteins <- de_genes %>% dplyr::filter(gene_biotype=="protein_coding") %>% pull(gene_name)
proteins_mapped <- rba_string_map_ids(ids = proteins,
                                      species = 9606)

proteins_mapped %>% as_tibble()

```

## Some examples with `rbioapi`

### Using STRING

#### Functional enrichment

Currently, STRING supports Gene Ontology, KEGG pathways, UniProt Keywords, PubMed publications, Pfam domains, InterPro domains, and SMART domains. (source).

```{r}
enriched <- rba_string_enrichment(ids = proteins_mapped$stringId,
                                  species = 9606 )
enriched %>% names()

enriched[["PMID"]] %>% as_tibble()

```

## Some examples with `rbioapi`

### Using STRING

#### Get functional annotations

As you have seen above, STRING maps the proteins to multiple annotation sources. You can obtain any annotation associated with your proteins without performing enrichment analysis and retrieving just the significant portion.

```{r}

annotations <- rba_string_annotations(ids = "9606.ENSP00000269305",
                                     species = 9606)

annotations$InterPro

```

## Some examples with `rbioapi`

### Using STRING

#### Protein-protein interaction enrichment

Even without incorporating annotation data, STRING can calculate if your proteins are functionally related. Briefly, STRING accomplishes this by comparing the interactions’ distribution in your protein-set to the interactions’ distribution in the proteome.

```{r}
rba_string_enrichment_ppi(ids = proteins_mapped$stringId,
                          species = 9606)
```


## Clusterprofiler for Metabolites

### Input data

In the lesson examples, I will be using a simulated data set based on a metabolic network.

```{r, eval=FALSE, echo=FALSE}
cond = zscores %>% as.data.frame() %>% select(2)  %>% rownames_to_column("id")
write.table(cond %>% rename("score" = 2), paste0("data/example_metab_data_",names(cond)[2],".tsv"), sep="\t", quote = F, row.names = F)
```

::: columns
::: {.column width="45%"}
Pathway sets

```{r, pathway-sets, echo=FALSE}
pathway_sets = read.table("data/metabolite_pathways.tsv", sep="\t", header = T) %>% 
  mutate(metabolite = str_remove(metabolite, "[a-z]$")) %>% relocate(subsystem)

metabolites = read.table("data/example_metab_data_Acylglycerides_metabolism.tsv", sep="\t", header = T) %>% arrange(desc(score)) %>% mutate(id = as.character(id)) %>% pull(score,id) %>% na.omit()

gsea.metab = GSEA(metabolites, TERM2GENE = pathway_sets,minGSSize = 3, pvalueCutoff = 1)
pathway_sets %>% dplyr::slice(sample(1:dplyr::n())) %>% head(15) %>% tibble()
```
:::

::: {.column width="10%"}
:::

::: {.column width="45%"}
Metabolomics data

```{r, metabo-data, echo=FALSE}
metabolites %>% enframe() %>% tibble() %>% head(15)
```
:::
:::

------------------------------------------------------------------------

### ORA

```{r, ora-data, echo=FALSE}
metabolites.ORA = read.table("data/example_metab_data_Acylglycerides_metabolism.tsv", sep="\t", header = T) %>% na.omit() %>% dplyr::filter(abs(score)> 1) %>% pull(id)
```

```{r, ora}
ora.metab = enricher(metabolites.ORA , TERM2GENE = pathway_sets)
dotplot(ora.metab)
```

------------------------------------------------------------------------

### GSEA/MSEA

#### GSEA example: results

```{r, gsea-results, echo=FALSE}
tibble(gsea.metab@result) %>% dplyr::filter(pvalue < 0.05) %>% dplyr::select(ID, setSize, NES, pvalue, core_enrichment) %>% head(8)
```

```{r, gsea-plot}
enrichplot::gseaplot2(gsea.metab, geneSetID = 8, title = gsea.metab$Description[8])
```

------------------------------------------------------------------------

```{r, gsea-dotplot}
dotplot(gsea.metab)
```


## MetaboAnalyst

MetaboAnalyst is an online platform for various steps of analysing metabolomics data.

![](images/metaboanalyst.png){fig-align="center"}

------------------------------------------------------------------------

It can be useful for a quick analysis but often remains unclear on the actual methods used. For example, it mentions MSEA in its description but never actually provides a GSEA or MSEA analysis.

![](images/metaboanalyst_enrichment.png){fig-align="center" width="277"}

::: callout-warning
Due to its online nature, reproducibility of results can be an issue between versions. Similarly, IMPaLA is an online interface for enriching genes and metabolites, but its results must be taken with a grain of salt since it combines many pathway databases into one in the results.
:::

------------------------------------------------------------------------

### Different MetaboAnalyst analyses

MetaboAnalyst provides interfaces for ORA, single sample profiling and QEA. ssprofiling and QEA are other enrichment methods that we will not go over during this course.

![](images/enrichment_analysis.png){fig-align="center" width="414"}

## Metexplore

### Biosources/metabolic networks

KEGG - E. coli

![](images/metabolic_network.png){fig-align="center"}

------------------------------------------------------------------------

![](images/biosource_stats.png){fig-align="center" width="343"}

------------------------------------------------------------------------

### ID mapping

-   Usually from "common names" to CHEBI

-   Most often requires a manual step for missing ID conversions

-   Can add a background set of metabolites for ORA

![](images/metexplore_mapping.png){fig-align="center" width="148"}

------------------------------------------------------------------------

![](images/metexplore_mapping_example.png){fig-align="center" width="507"}

------------------------------------------------------------------------

### Pathway analysis

-   Once a metabolite dataset has been mapped to a network, pathway analysis (ORA) is done automatically using the mapped data

-   Can be viewed in a table with multiple test corrections

![](images/metexplore_pathway_enrichment.png){fig-align="center"}

------------------------------------------------------------------------

### Visualisation

-   Can visualise a subset of metabolites and reactions, or entire pathways

-   Highlight metabolites of interest

![](images/metexplore_viz.png){fig-align="center"}

## FELLA

-   Uses KEGG network and a list of KEGG metabolites

-   Represents KEGG as a knowledge graph with hierarchical connections from metabolites to pathways through reactions, enzymes...

## FELLA: example

```{r, fella-data, echo=FALSE}
data("FELLA.sample")
input.sample = read.table("data/epithelial_input.csv", sep= ",", header = T)
```

```{r, fella-build-kegg, echo=FALSE}
#| eval: false

# Only needs to be run once to create the file

graph <- buildGraphFromKEGGREST(
 organism = "hsa",
 filter.path = c("01100", "01200", "01210", "01212", "01230"))

buildDataFromGraph(
 keggdata.graph = graph,
 databaseDir = "kegg_db/",
 internalDir = FALSE,
 matrices = "diffusion",
 normality = "diffusion",
 niter = 50)

fella.data <- loadKEGGdata(
 databaseDir = "kegg_db",
 internalDir = FALSE,
 loadMatrix = NULL
 )
myAnalysis = FELLA::enrich(compounds = input.sample%>% pull(KEGG.id), method = "diffusion", 
    approx = "normality",
    data = fella.data)
```


```{r, fella-generate-graph, echo=FALSE}
myAnalysis <- readRDS("data/myAnalysis.rds")
fella.data <- readRDS("data/fella.data.rds")
g <- generateResultsGraph(object = myAnalysis, data = fella.data)
v.size <- c(
  "1" = 10,
  "2" = 6,
  "3" = 5,
  "4" = 4,
  "5" = 2
)
v.color <- stats::setNames(grDevices::palette()[1:5], 1:5)

```

```{r, fella-fig, echo=FALSE, fig.width=6, fig.height=7}
#| fig-width: 17
#| fig-height: 10
plotGraph(g, 
     vertex.size = v.size[V(g)$com], 
     vertex.color = v.color[V(g)$com], 
     # only show level 1 (pathway) and 5 (compound)
     vertex.label = ifelse(V(g)$com %in% c(1, 5), V(g)$label, ""), 
     vertex.label.dist = 1, 
     vertex.label.color = ifelse(V(g)$name %in% input.sample, 
                                 "indianred1", "gray20"), 
     edge.width = 3,
     nlimit = 150)
```


# Visualisation of enrichment results

## Basic visualisations: Dotplot

```{r}
#| echo: false

dotplot(ego,showCategory=10)
```

## Basic visualisations: Gene-Concept Network

```{r}
#| echo: false
#| warning: false
#| message: false
y <- setReadable(ego, OrgDb = org.db, keyType="ENSEMBL")
p1 <- cnetplot(y, foldChange=geneList, node_label="none", 
        color_category='firebrick', 
        color_gene='steelblue')
print(p1)
```

## Basic visualisations: UpSet plots

```{r}
#| echo: false
#| warning: false
#| message: false

upsetplot(ego)
```

> For GSEA result, it will plot the fold change distributions of different categories (e.g. unique to pathway, overlaps among different pathways).

## Basic visualisations: Gene-Concept Network

```{r}
#| echo: false
#| warning: false
#| message: false
y <- setReadable(ego, OrgDb = org.db, keyType="ENSEMBL")
p2 <- heatplot(y, foldChange=geneList, showCategory=5)
print(p2)
```


# Beyond Enrichment

## Relationship between pathway using term similarity

### Enrichment Map

```{r}
#| echo: false
#| warning: false
#| message: false

ego <- pairwise_termsim(ego)
emapplot(ego, showCategory = 10)
```

## Relationship between pathway using term similarity

### Tree plot

```{r}
#| echo: false
#| warning: false
#| message: false

treeplot(ego)
```



## Relationship between pathway and products (features) using semantic

### Functional similarity of gene products can be estimated by controlled biological vocabularies, using __semantic similarity measures__. 

#### The semantic similarity measures take into account the distance or information content between terms in the ontology. 

Known measures: 
* IC based: Resnik, Lin, Schlicker, and Jiang-Conrath. 
* Graph based: Wang (graph structure of GO).

See [clusterProfiler book](https://yulab-smu.top/biomedical-knowledge-mining-book/semantic-similarity-overview.html) for more details.

## Relationship between pathway and products (features) using `GOSemSim`

```{r}
#| warning: false
#| message: false


library(GOSemSim)
hsGO <- godata(org.db, ont="BP",keytype = "ENSEMBL")
```

### Get GO similarity based on genes sets

```{r}
goSim("GO:0098813", "GO:0007059", semData=hsGO, measure="Jiang")
```

```{r}
mgoSim(as_tibble(ego)$ID, as_tibble(ego)$ID, semData=hsGO, measure="Jiang", combine=NULL)
```

## Relationship between pathway and products (features) using `GOSemSim`


### Get gene similarity based on go terms

```{r}
mgeneSim(genes=de_genes$rowname[1:10],
         semData=hsGO, measure="Wang",verbose=FALSE)
```

## References

-   Wieder C, Frainay C, Poupin N, Rodríguez-Mier P, Vinson F, Cooke J, et al. (2021) **Pathway analysis in metabolomics: Recommendations for the use of over-representation analysis.** PLoS Comput Biol 17(9): e1009105. https://doi.org/10.1371/journal.pcbi.1009105
-   Subramanian A, Tamayo P, Mootha VK, Mukherjee S, Ebert BL, Gillette MA, Paulovich A, Pomeroy SL, Golub TR, Lander ES, Mesirov JP. **Gene set enrichment analysis: a knowledge-based approach for interpreting genome-wide expression profiles.** Proc Natl Acad Sci U S A. 2005 Oct 25;102(43):15545-50. doi: 10.1073/pnas.0506580102. Epub 2005 Sep 30. PMID: 16199517; PMCID: PMC1239896.

